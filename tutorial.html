<!DOCTYPE html PUBLIC ""
    "">
<html><head><meta charset="UTF-8" /><title>A Quick but Eventful Tutorial</title><link rel="stylesheet" type="text/css" href="css/default.css" /><link rel="stylesheet" type="text/css" href="css/highlight.css" /><script type="text/javascript" src="js/highlight.min.js"></script><script type="text/javascript" src="js/jquery.min.js"></script><script type="text/javascript" src="js/page_effects.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div id="header"><h2>Generated by <a href="https://github.com/weavejester/codox">Codox</a></h2><h1><a href="index.html"><span class="project-title"><span class="project-name">Eventful</span> <span class="project-version">0.1.0-alpha2</span></span></a></h1></div><div class="sidebar primary"><h3 class="no-link"><span class="inner">Project</span></h3><ul class="index-link"><li class="depth-1 "><a href="index.html"><div class="inner">Index</div></a></li></ul><h3 class="no-link"><span class="inner">Topics</span></h3><ul><li class="depth-1  current"><a href="tutorial.html"><div class="inner"><span>A Quick but Eventful Tutorial</span></div></a></li></ul><h3 class="no-link"><span class="inner">Namespaces</span></h3><ul><li class="depth-1 "><a href="eventful.core.html"><div class="inner"><span>eventful.core</span></div></a></li></ul></div><div class="document" id="content"><div class="doc"><div class="markdown"><h1><a href="#a-quick-but-eventful-tutorial" name="a-quick-but-eventful-tutorial"></a>A Quick but Eventful Tutorial</h1>
<h2><a href="#getting-started" name="getting-started"></a>Getting Started</h2>
<p>After the <a href="https://eventstore.org/">Event Store</a> is successfully installed and started, the obvious next step is to connect to it:</p>
<pre><code class="clojure">(use 'eventful.core)
=&gt; nil
(def conn (connect {:hostname "127.0.0.1" :port 1113
                    :login    "admin"     :password "changeit"}))
=&gt; #'user/conn
</code></pre>
<h2><a href="#writing-events" name="writing-events"></a>Writing Events</h2>
<p>Now we can write the first two events in this tutorial (there will be more):</p>
<pre><code class="clojure">(write-events {:conn conn :stream "inventory-item-1" :exp-ver :no-stream}
              {:event :created :name "foo"}
              {:event :items-checked-in :count 100})
=&gt; &lt;&lt; … &gt;&gt;
</code></pre>
<p>Let’s investigate if it all worked out:</p>
<pre><code class="clojure">@*1
=&gt; {:next-exp-ver 1, :pos {:commit 16796, :prepare 16796}}
</code></pre>
<p>We can use the <code>:next-exp-ver</code> above to add another event:</p>
<pre><code class="clojure">(write-events {:conn conn :stream "inventory-item-1" :exp-ver 1}
              {:event :renamed :new-name "bar"})
=&gt; &lt;&lt; … &gt;&gt;
@*1
=&gt; {:next-exp-ver 2, :pos {:commit 46786, :prepare 46786}}
</code></pre>
<h2><a href="#transactions" name="transactions"></a>Transactions</h2>
<p>Transactions are supported as well. Maybe adding three more events is not such a bad idea:</p>
<pre><code class="clojure">(def tx @(tx-start {:conn conn :stream "inventory-item-1" :exp-ver 2}))
=&gt; #'user/tx
@(tx-write-events {:tx tx}
                  {:event :items-removed :count 1}
                  {:event :items-removed :count 2})
=&gt; :done
@(tx-write-events {:tx tx}
                  {:event :items-removed :count 3})
=&gt; :done
@(tx-commit tx)
=&gt; :done
</code></pre>
<h2><a href="#reading-events" name="reading-events"></a>Reading Events</h2>
<p>Let’s verify that all events are really there:</p>
<pre><code class="clojure">(-&gt;&gt; (for [num (range 6)]
       (read-event {:conn conn :stream "inventory-item-1"} num))
     (map deref))
=&gt;
({:event :created, :name "foo"}
 {:event :items-checked-in, :count 100}
 {:event :renamed, :new-name "bar"}
 {:event :items-removed, :count 1}
 {:event :items-removed, :count 2}
 {:event :items-removed, :count 3})
</code></pre>
<p>Alternatively, we can get the events in one call. Let’s get the first 5 events:</p>
<pre><code class="clojure">@(read-stream {:conn conn :stream "inventory-item-1"} [nil 5])
=&gt;
[{:event :created, :name "foo"}
 {:event :items-checked-in, :count 100}
 {:event :renamed, :new-name "bar"}
 {:event :items-removed, :count 1}
 {:event :items-removed, :count 2}]
</code></pre>
<p>Changing <code>5</code> to <code>-5</code> returns the last 5 events in reverse order:</p>
<pre><code class="clojure">@(read-stream {:conn conn :stream "inventory-item-1"} [nil -5])
=&gt;
[{:event :items-removed, :count 3}
 {:event :items-removed, :count 2}
 {:event :items-removed, :count 1}
 {:event :renamed, :new-name "bar"}
 {:event :items-checked-in, :count 100}]
</code></pre>
<p>Metadata is returned with each event:</p>
<pre><code class="clojure">(-&gt; *1 first meta)
=&gt;
{:id #uuid"3c2034b4-71cf-48d6-a17f-98ef9ddb1653",
 :type "event",
 :num 5,
 :stream "inventory-item-1",
 :date #object[org.joda.time.DateTime 0x56009895 "2018-01-10T19:51:48.554Z"]}
</code></pre>
<h2><a href="#subscriptions" name="subscriptions"></a>Subscriptions</h2>
<p>With the basics out of the way, we can now look at subscribing to a stream:</p>
<pre><code class="clojure">(subscribe-to-stream {:conn conn :stream "inventory-item-1" :from 0}
                     {:event (partial prn "Received:")})
=&gt;
#object[eventstore.util.ActorCloseable
        0x444c0538
        "ActorCloseable(Actor[akka://Eventful/user/$c#-537978204])"]
Received: {:event :created, :name foo}
Received: {:event :items-checked-in, :count 100}
Received: {:event :renamed, :new-name bar}
Received: {:event :items-removed, :count 1}
Received: {:event :items-removed, :count 2}
Received: {:event :items-removed, :count 3}
</code></pre>
<p>We should receive an event as soon as it is written (but not sooner):</p>
<pre><code class="clojure">@(write-events {:conn conn :stream "inventory-item-1" :exp-ver 5}
               {:event :items-removed :count 4})
=&gt; {:next-exp-ver 6, :pos {:commit 137294, :prepare 137294}}
Received: {:event :items-removed, :count 4}
</code></pre>
<p>Now we can close our subscription:</p>
<pre><code class="clojure">(close-subscription *2)
=&gt; nil
</code></pre>
<h2><a href="#persistent-subscriptions" name="persistent-subscriptions"></a>Persistent Subscriptions</h2>
<p>Thanks to our persistence we advanced to the <a href="eventful.core.html#var-persistently-subscribe">persistent subscriptions</a>:</p>
<pre><code class="clojure">@(create-persistent-subscription
   {:conn conn :stream "inventory-item-1" :group "baz"} {:from 0})
=&gt; :done
(persistently-subscribe {:conn conn :stream "inventory-item-1" :group "baz"}
                        {:event (partial prn "Persistently received:")})
=&gt;
#object[akka.actor.RepointableActorRef
        0x2812b316
        "Actor[akka://Eventful/user/$f#1630272201]"]
Persistently received: {:event :created, :name foo}
Persistently received: {:event :items-checked-in, :count 100}
Persistently received: {:event :renamed, :new-name bar}
Persistently received: {:event :items-removed, :count 1}
Persistently received: {:event :items-removed, :count 2}
Persistently received: {:event :items-removed, :count 3}
Persistently received: {:event :items-removed, :count 4}
</code></pre>
<p>This time too we should receive an event as soon as it is written. No surprise there:</p>
<pre><code class="clojure">@(write-events {:conn conn :stream "inventory-item-1" :exp-ver 6}
               {:event :items-removed :count 5})
=&gt; {:next-exp-ver 7, :pos {:commit 182729, :prepare 182729}}
Persistently received: {:event :items-removed, :count 5}
</code></pre>
<p>Let’s close this subscription (for now):</p>
<pre><code class="clojure">(close-subscription *2)
=&gt; nil
</code></pre>
<p>If we add another event and reopen our persistent subscription, we will receive it. Also, let’s find out how to use the manual ACK as opposed to the default automatic ACK:</p>
<pre><code class="clojure">@(write-events {:conn conn :stream "inventory-item-1" :exp-ver 7}
               {:event :items-removed :count 6})
=&gt; {:next-exp-ver 8, :pos {:commit 197943, :prepare 197943}}
(declare sub)
=&gt; #'user/sub
(def sub (persistently-subscribe
           {:conn conn :stream "inventory-item-1" :group "baz" :auto-ack false}
           {:event (fn [event]
                     (prn "Persistently received (2):" event)
                     (manual-ack sub event))}))
=&gt; #'user/sub
Persistently received (2): {:event :items-removed, :count 6}
</code></pre>
<p>Finally let’s close this subscription so it does not print any more events:</p>
<pre><code class="clojure">(close-subscription sub)
=&gt; nil
</code></pre>
<h2><a href="#json" name="json"></a>JSON</h2>
<p>By default Eventful will write &amp; read events in EDN. To use JSON instead, we need to do few things:</p>
<ol>
  <li>Include the cheshire dependency in our project.</li>
  <li>Require the <code>eventful.json</code> namespace.</li>
  <li>Use the <code>:format</code> option when writing &amp; reading.</li>
</ol>
<p>I’ll leave the first step for you. Go on and add the dependency then restart your REPL and reconnect to the Event Store. The remaining two steps are:</p>
<pre><code class="clojure">(require 'eventful.json)
=&gt; nil
@(write-events {:conn conn :stream "inventory-item-1" :exp-ver 8 :format :json}
               {:event :items-removed :count 7})
=&gt; {:next-exp-ver 9, :pos {:commit 1228589, :prepare 1228589}}
@(read-event {:conn conn :stream "inventory-item-1" :format :json} 9)
=&gt; {"event" "items-removed", "count" 7}
</code></pre>
<h2><a href="#further-events" name="further-events"></a>Further Events</h2>
<p>We wrote a total of 10 events in this tutorial! Didn’t we say it will be Eventful? But that’s not all. To write even more, check out the <a href="eventful.core.html">API Docs</a>! Happy eventing!</p></div></div></div></body></html>